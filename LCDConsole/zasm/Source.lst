              	; --------------------------------------
              	; zasm: assemble "Source.asm"
              	; opts: --z180
              	; date: 2020-06-18 16:45:28
              	; --------------------------------------


              	; **********************************************************************
              	; **  I2C LCD console demo  by Francis Pierot                         **
              	; **  Original I2C code by Stephen S. Cousins                         **
              	; **********************************************************************
              	
              	; This program demonstrates the use of LCD Console on a SC126 I2C port
              	; with a 4x20 LCD display + I2C adapter.
              	;
              	
              	;#TARGET     Simulated_Z80       ; Determines hardware support included
              	
              	;            .PROC Z180          ;SC126 has a Z180
              	;           .HEXBYTES 0x18      ; Intel format output size
              	
              	;            .DATA
              	;            .ORG 0x9000         ; adjust this depending on code size
              	
              	; ZASM Syntax. ZASM HEX output seems to concatenate segments from 0000 whatever
              	; their ORG is, so a loader is needed to put code segment at the destination address
              	; at start. using BIN target doesn't seem to make a difference from ROM. It's disturbing
              	; because listing file shows the correct addresses.
              	;
              	; xxx_size labels are generated by ZASM from the relevant segment size after pass 2. Notice these
              	; automatic labels are case dependent.
              	;
              	; three segments are defined here: _BOOT will start at $0000 and load code into $8000 area and 
              	; jump to it, _CODE will hold all the code, and _DATA will be the space for variables which is 
              	; put at end of 64K with stack pointer moved before this variables space.
              	;
              	#TARGET BIN        
0000:         	#CODE       _BOOT,0000h
              	            ORG $0000
              	            ; load code to actual address
0000: 110080  	            LD DE,_CODE
0003: 211100  	            LD HL,_BOOT_size
0006: 01A403  	            LD BC,_CODE_size
0009: EDB0    	            LDIR
              	            ; adjust SP before variables storage
000B: 31A0FF  	            LD SP,$ffff-_DATA_size
              	            ; now we can jump to code address
000E: C30080  	            JP PROGRAMSTART
              	;'stack_top' is a label for DeZog debugger in Visual Code            
FFA0:         	stack_top:  .EQU $ffff-_DATA_size
              	
              	; DATA segment can be put anywhere in RAM, here we put it at the end of 64K.
FFA0:         	#DATA       _DATA,$ffff-_DATA_size
              	            ORG $ffff-_DATA_size
              	
8000:         	#CODE       _CODE,$8000,*
              	            ORG $8000
              	
              	; Optional code, insert functions or not
0000:         	USE_I2CREAD .EQU 0              ;optional I2C reading
0000:         	USE_LCDPRINT .EQU 0             ;optional I2C string print out of console
              	; Constants needed by the I2C support module
000C:         	I2C_PORT:   .EQU 0x0C           ;Host I2C port address
0007:         	I2C_SDA_WR: .EQU 7              ;Host I2C write SDA bit number
0000:         	I2C_SCL_WR: .EQU 0              ;Host I2C write SCL bit number
0007:         	I2C_SDA_RD: .EQU 7              ;Host I2C read SDA bit number
004E:         	I2C_ADDR:   .EQU 0x27 << 1      ;I2C device default address (8574T with A0=A1=A2=1), bit 0 = 0 for R/W
              	
              	; LCD constants required by LCD support module
0000:         	kLCDBitRS:  .EQU 0              ;data bit for LCD RS signal
0001:         	kLCDBitRW:  .EQU 1              ;data bit for LCD R/W signal
0002:         	kLCDBitE:   .EQU 2              ;data bit for LCD E signal
0003:         	kLCDBitBL:  .EQU 3              ;data bit for backlighting
0014:         	kLCDWidth:  .EQU 20             ;Width in characters
              	
              	
8000:         	PROGRAMSTART:
              	
              	; Initialise I2C and alphanumeric LCD module
8000: CD8682  	            CALL fLCD_Init      ;Initialise LCD module
              	
              	; Define custom character(s)
8003: 3E00    	            LD   A, 0           ;First character to define (0 to 7)
8005: 115680  	            LD   DE, BitMaps    ;Pointer to start of bitmap data
8008: 0602    	            LD   B, 2           ;Number of characters to define
              	#local
800A: CD6183  	DefLoop:    CALL fLCD_Def       ;Define custom character
800D: 10FB    	            DJNZ DefLoop       ;Repeat for each character
              	#endlocal
              	; Initialize console
800F: CDEF80  	            CALL LCDConsoleInit
              	
              	; Clear display (already done in console init, this is for example only)
8012: CDDD81  	            CALL LCDClear            
              	
              	; Display text on first line
8015: CDC981  	            CALL LCDString
8018: 48656C6C	            .DB "Hello, world!",0Ah,0
801C: 6F2C2077	
8020: 6F726C64	
8024: 210A00  	
              	
              	; Display text on second line
8027: CDC981  	            CALL LCDString
802A: 49276D20	            .DB "I'm an SCZ180/126",0Ah,0
802E: 616E2053	
8032: 435A3138	
8036: 302F3132	
803A: 360A00  	
              	
              	; Display custom character 0 on the right 1st line
803D: 011300  	            LD BC,0013h
8040: CD2781  	            CALL LCDSetCur
8043: 3E00    	            LD A,0
8045: CD6181  	            CALL LCDChar
              	
              	; Display custom character 1 on the right 2nd line
8048: 011301  	            LD BC,0113h
804B: CD2781  	            CALL LCDSetCur
804E: 3E01    	            LD A,1
8050: CD6181  	            CALL LCDChar
              	
8053: C35380  	            JP $                ; finished
              	
              	; Custom characters 5 pixels wide by 8 pixels high
              	; Up to 8 custom characters can be defined
8056:         	BitMaps:
              	; Character 0x00 = Battery icon
8056: 0E      	            .DB  0b01110
8057: 1B      	            .DB  0b11011
8058: 11      	            .DB  0b10001
8059: 11      	            .DB  0b10001
805A: 1F      	            .DB  0b11111
805B: 1F      	            .DB  0b11111
805C: 1F      	            .DB  0b11111
805D: 1F      	            .DB  0b11111
              	; Character 0x01 = Bluetooth icon
805E: 06      	            .DB  0b00110
805F: 15      	            .DB  0b10101
8060: 0E      	            .DB  0b01110
8061: 04      	            .DB  0b00100
8062: 0E      	            .DB  0b01110
8063: 15      	            .DB  0b10101
8064: 06      	            .DB  0b00110
8065: 00      	            .DB  0b00000
              	
              	
              	
              	; **********************************************************************
              	; **  Includes
              	; **********************************************************************
              	            INCLUDE    "I2C.asm"
              	; **********************************************************************
              	; **  I2C control functions                     by Stephen C Cousins  **
              	; **********************************************************************
              	;
              	; This code has delays between all I/O operations to ensure it works
              	; with the slowest I2C devices
              	;
              	; I2C transfer sequence
              	;   +-------+  +---------+  +---------+     +---------+  +-------+
              	;   | Start |  | Address |  | Data    | ... | Data    |  | Stop  |
              	;   |       |  | frame   |  | frame 1 |     | frame N |  |       |
              	;   +-------+  +---------+  +---------+     +---------+  +-------+
              	;
              	;
              	; Start condition                     Stop condition
              	; Output by master device             Output by master device
              	;       ----+                                      +----
              	; SDA       |                         SDA          |
              	;           +-------                        -------+
              	;       -------+                                +-------
              	; SCL          |                      SCL       |
              	;              +----                        ----+
              	;
              	;
              	; Address frame
              	; Clock and data output from master device
              	; Receiving device outputs acknowledge 
              	; For 8574T  the address of LCD I2C is 0 1 0 0 A2 A1 A0 (20 to 27)
              	; For 8574TA it's 0 1 1 1 A2 A1 A0 (38 to 3F)
              	; These bits go into A7 to A1 and are followed by a 0 for R/W
              	;          +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
              	; SDA      | A 7 | A 6 | A 5 | A 4 | A 3 | A 2 | A 1 | R/W | ACK |   |
              	;       ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
              	;            +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
              	; SCL        | |   | |   | |   | |   | |   | |   | |   | |   | |
              	;       -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
              	;
              	;
              	; Data frame 
              	; Clock output by master device
              	; Data output by transmitting device
              	; Receiving device outputs acknowledge 
              	; D7 to D4 are for the 4-bit nibbles of data (send in 2 successive data frames)
              	; D3 is for backlight control
              	; D2 is E (start data read/write)
              	; D1 is R/W (Write when 0)
              	; D0 is Rs : register select 0=instruction, 1=data
              	;          +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
              	; SDA      | D 7 | D 6 | D 5 | D 4 | D 3 | D 2 | D 1 | D 0 | ACK |   |
              	;       ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
              	;            +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
              	; SCL        | |   | |   | |   | |   | |   | |   | |   | |   | |
              	;       -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
              	;
              	;
              	;
              	; I2C_PORT must be defined before including this file:
              	; I2C_PORT:   .EQU 0x0C           ;Host I2C port address (SC126)
              	;
              	; I2C_Open    Starts I2C sequence with adress frame (device address << 1 in A)
              	; I2C_Close   Ends sequence
              	; I2C_Write   Transmit frame (data or instruction)
              	; I2C_Read    Receive data frame
              	;**********************************************************************************************
              	
              	#CODE _CODE
              	
              	; I2C bus open device
              	;   On entry: A = Device address (bit zero is read flag)
              	;             SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A = 0 and Z flagged
              	;             If successfully A = Error and NZ flagged
              	;             SCL = lo, SDA = lo
              	;             HL IX IY preserved
              	; Possible errors:  1 = Bus jammed (not implemented)
8066: F5      	I2C_Open:   PUSH AF
8067: CDA680  	            CALL I2C_Start      ;Output start condition
806A: F1      	            POP  AF
806B: 1802    	            JR   I2C_Write      ;Write data byte
              	
              	
              	; I2C bus close device
              	;   On entry: SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A=0 and Z flagged
              	;             If successfully A=Error and NZ flagged
              	;             SCL = hi, SDA = hi
              	;             HL IX IY preserved
              	; Possible errors:  1 = Bus jammed ??????????
806D: 1844    	I2C_Close:  JR   I2C_Stop       ;Output stop condition
              	
              	
              	; I2C bus transmit frame (address or data)
              	;   On entry: A = Data byte, or
              	;                 Address byte (bit zero is read flag)
              	;             SCL = low, SDA = low
              	;   On exit:  If successful A=0 and Z flagged
              	;                SCL = lo, SDA = lo
              	;             If unsuccessful A=Error and NZ flagged
              	;                SCL = high, SDA = high, I2C closed
              	;             HL IX IY preserved
806F: 57      	I2C_Write:  LD   D,A            ;Store byte to be written
8070: 0608    	            LD   B,8            ;8 data bits, bit 7 first
8072: CB12    	Wr_Loop:   RL   D              ;Test M.S.Bit
8074: 3805    	            JR   C,Bit_Hi      ;High, so skip
8076: CDD580  	            CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = data bit)
8079: 1803    	            JR   Bit_Clk
807B: CDCE80  	Bit_Hi:    CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA = data bit)
807E: CDC080  	Bit_Clk:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = data bit)
8081: CDC780  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = data bit)
8084: 10EC    	            DJNZ Wr_Loop
              	; Test for acknowledge from slave (receiver)
              	; On arriving here, SCL = lo, SDA = data bit
8086: CDCE80  	            CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/ack)
8089: CDC080  	            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/ack)
808C: CDE680  	            CALL I2C_RdPort     ;Read SDA input
808F: 47      	            LD   B,A
8090: CDC780  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = hi)
8093: CB78    	            BIT  I2C_SDA_RD,B
8095: 2002    	            JR   NZ,NoAck      ;Skip if no acknowledge
8097: AF      	            XOR  A              ;Return success A=0 and Z flagged
8098: C9      	            RET
              	; I2C STOP required as no acknowledge
              	; On arriving here, SCL = lo, SDA = hi
8099: CDD580  	NoAck:     CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = lo)
809C: CDC080  	            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = lo)
809F: CDCE80  	            CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA = hi)
80A2: 3E02    	            LD   A,2            ;Return error 2 - No Ack
80A4: B7      	            OR   A              ;  and NZ flagged
80A5: C9      	            RET
              	
              	
              	;*** UNUSED *****
              	; I2C bus receive frame (data)
              	;   On entry: SCL low, SDA low
              	;   On exit:  If successful A = data byte and Z flagged
              	;               SCL = low, SDA = low
              	;             If unsuccessul A = Error and NZ flagged
              	;               SCL = low, SDA = low ??? no failures supported
              	;             HL IX IY preserved
              	#IF USE_I2CREAD
              	I2C_Read:   LD   B,8            ;8 data bits, 7 first
              	            CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/input)
              	Rd_Loop:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/input)
              	            CALL I2C_RdPort     ;Read SDA input bit
              	            SCF                 ;Set carry flag
              	            BIT  I2C_SDA_RD,A   ;SDA input high?
              	            JR   NZ,Rotate     ;Yes, skip with carry flag set
              	            CCF                 ;Clear carry flag
              	Rotate:    RL   D              ;Rotate result into D
              	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA hi/input)
              	            DJNZ Rd_Loop       ;Repeat for all 8 bits
              	; Acknowledge input byte
              	; On arriving here, SCL = lo, SDA = hi/input
              	            CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA lo)
              	            CALL I2C_SCL_HI     ;SCL hi    (SCL hi, SDA lo)
              	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
              	            LD   A,D            ;Get data byte received
              	            CP   A              ;Return success Z flagged
              	            RET
              	#ENDIF
              	
              	; I2C bus start
              	;   On entry: SCL = unknown, SDA = unknown
              	;   On exit:  SCL = low, SDA = low
              	;             BC DE HL IX IY preserved
              	; First ensure SDA and SCL are high
80A6: CDC080  	I2C_Start:  CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA ??)
80A9: CDCE80  	            CALL I2C_SDA_HI     ;SDA high  (SCL hi, SDA hi)
              	; Generate I2C start condition
80AC: CDD580  	            CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
80AF: CDC780  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
80B2: C9      	            RET
              	
              	
              	; I2C bus stop 
              	;   On entry: SCL = unknown, SDA = unknown
              	;   On exit:  SCL = high, SDA = high
              	;             BC DE HL IX IY preserved
              	; First ensure SDA and SCL are low
80B3: CDD580  	I2C_Stop:   CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
80B6: CDC780  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
              	; Generate stop condition
80B9: CDC080  	            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA lo)
80BC: CDCE80  	            CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA hi)
80BF: C9      	            RET
              	
              	
              	; **********************************************************************
              	; I2C bus simple I/O functions
              	;   On entry: No parameters required
              	;   On exit:  BC DE HL IX IY preserved
              	
80C0: 3AA0FF  	I2C_SCL_HI: LD   A,(I2C_RAMCPY)
80C3: CBC7    	            SET  I2C_SCL_WR,A
80C5: 1813    	            JR   I2C_WrPort
              	
80C7: 3AA0FF  	I2C_SCL_LO: LD   A,(I2C_RAMCPY)
80CA: CB87    	            RES  I2C_SCL_WR,A
80CC: 180C    	            JR   I2C_WrPort
              	
80CE: 3AA0FF  	I2C_SDA_HI: LD   A,(I2C_RAMCPY)
80D1: CBFF    	            SET  I2C_SDA_WR,A
80D3: 1805    	            JR   I2C_WrPort
              	
80D5: 3AA0FF  	I2C_SDA_LO: LD   A,(I2C_RAMCPY)
80D8: CBBF    	            RES  I2C_SDA_WR,A
              	            ;JR   I2C_WrPort
              	
              	; **********************************************************************
              	; I2C bus write
              	;   On entry: A byte to send
              	;   On exit:  BC DE HL IX IY preserved
80DA: C5      	I2C_WrPort: PUSH BC
80DB: 0600    	            LD   B,0            ;Set up BC for 16-bit
80DD: 0E0C    	            LD   C,I2C_PORT     ;  I/O address of I2C port
80DF: ED79    	            OUT  (C),A          ;Write A to I2C I/O port
80E1: 32A0FF  	            LD   (I2C_RAMCPY),A ;Write A to RAM copy
80E4: C1      	            POP  BC
80E5: C9      	            RET
              	
              	; **********************************************************************
              	; I2C bus read
              	;   On entry: No parameters required
              	;   On exit:  BC DE HL IX IY preserved, A byte read
80E6: C5      	I2C_RdPort: PUSH BC
80E7: 0600    	            LD   B,0            ;Set up BC for 16-bit
80E9: 0E0C    	            LD   C,I2C_PORT     ;  I/O address of I2C port
80EB: ED78    	            IN   A,(C)          ;Read A from I/O port
80ED: C1      	            POP  BC
80EE: C9      	            RET
              	
              	
              	; **********************************************************************
              	; Workspace / variable in RAM
              	#DATA _DATA
FFA0: 00      	I2C_RAMCPY: .DB  0
              	            INCLUDE    "LCDConsole.asm"
              	;---------------------------------------------------------------------------
              	; LCDConsole - set of functions for a console 
              	; LCDSetCur : set the cursor position
              	; LCDChar : outputs a character
              	; LCDClear : clears screen 
              	; LCDScrollUp : scrolls screen one line up and clears bottom line
              	;---------------------------------------------------------------------------
              	;            .CODE
              	#CODE _CODE
              	            ; INIT for classical 4x20 Hitachi protocol
80EF:         	LCDConsoleInit:                 
80EF: F5      	            PUSH AF
80F0: E5      	            PUSH HL
              	            ; program I2C port
80F1: 3E0C    	            LD A,0x0C
80F3: 32F7FF  	            LD (LCDPORT),A
              	            ; clear cursor position 
80F6: AF      	            XOR A        
80F7: 32F2FF  	            LD (LCDPOSX),A
80FA: 32F3FF  	            LD (LCDPOSY),A
              	            ; set initial options : I2C and cursor
80FD: CBC7    	            SET LCBIT_I2C,A
80FF: CBE7    	            SET LCBIT_CURSOR,A
8101: 32F5FF  	            LD (LCDCONTROL),A
              	            ; set device default address
8104: 3E27    	            LD A,0x27
8106: 32F8FF  	            LD (I2CDEVICE),A
              	            ; set 4x20 default size
8109: 3E04    	            LD A,4
810B: 32FAFF  	            LD (LCDROWS),A
810E: 3E14    	            LD A,20
8110: 32F9FF  	            LD (LCDCOLS),A
              	            ; initialize line start indices
8113: 21FBFF  	            LD HL,LCD_INDEX     ; 0x00, 0x40, 0x00+20, 0x40+20
8116: 3600    	            LD (HL),0
8118: 23      	            INC HL
8119: 3640    	            LD (HL),0x40
811B: 23      	            INC HL
811C: 3AF9FF  	            LD A,(LCDCOLS)
811F: 77      	            LD (HL),A
8120: 23      	            INC HL
8121: C640    	            ADD A,0x40
8123: 77      	            LD (HL),A
              	            ; done with init
              	            ;CALL LCDClear
8124: E1      	            POP HL
8125: F1      	            POP AF
8126: C9      	            RET
              	
              	;            .CODE
              	
              	;---------------------------------------------------------------------------
              	; LCDSetCur : set the cursor position
              	; IN: X position in B, Y position in C
              	;---------------------------------------------------------------------------
8127: F5      	LCDSetCur:  PUSH AF
8128: 3AF9FF  	            LD A,(LCDCOLS)
812B: B8      	            CP B                ; LCDCOLS < X : C set
812C: 2802    	            JR Z,XNOTOK        ; x = LCDCOLS : not ok
812E: 3002    	            JR NC,XOK          ; X < LCDCOLS -> ok
8130: 3D      	XNOTOK:     DEC A               ; LCDCOLS - 1
8131: 47      	            LD B,A              ; X clamped at LCDCOLS-1
8132: 78      	XOK:        LD A,B              ; reload X
8133: 32F2FF  	            LD (LCDPOSX),A
8136: 3AFAFF  	            LD A,(LCDROWS)
8139: B9      	            CP C                ; LCDROWS < Y : C set
813A: 2802    	            JR Z,YNOTOK        ; y = LCDROWS -> not ok
813C: 3002    	            JR NC,YOK          ; y < LCDROWS -> ok
813E: 3D      	YNOTOK:    DEC A
813F: 4F      	            LD C,A              ; y clamped at LCDROWS-1
8140: 79      	YOK:       LD A,C              ; reload Y
8141: 32F3FF  	            LD (LCDPOSY),A
8144: CD4981  	            CALL LCDSetCurVar
8147: F1      	            POP AF
8148: C9      	            RET
              	
              	; Set cursor from the X/Y variables
8149:         	LCDSetCurVar:
8149: F5      	            PUSH AF
814A: E5      	            PUSH HL
814B: 3AF3FF  	            LD A,(LCDPOSY)
              	            ; add line number Y to index address
814E: 21FBFF  	            LD HL,LCD_INDEX
8151: 85      	            ADD A,L
8152: 6F      	            LD L,A
8153: 8C      	            ADC A,H
8154: 95      	            SUB L
8155: 67      	            LD H,A
              	            ; get the starting position for this line
8156: 7E      	            LD A,(HL)
              	            ; add column number
8157: 21F2FF  	            LD HL,LCDPOSX
815A: 86      	            ADD A,(HL)
              	            ; and send command
815B: CD4E83  	            CALL fLCD_Pos
815E: E1      	            POP HL
815F: F1      	            POP AF
8160: C9      	            RET
              	
              	;---------------------------------------------------------------------------
              	; LCDChar : outputs a character and update cursor position
              	; IN: character in A
              	; flags not preserved
              	;---------------------------------------------------------------------------
8161: E5      	LCDChar:    PUSH HL             ; save
              	            ; have to test line feed ?
8162: 21F5FF  	            LD HL,LCDCONTROL
8165: CB7E    	            BIT LCBIT_NOLF,(HL)
8167: 2008    	            JR NZ,NOTLF
              	            ; do not ignore LF
8169: FE0A    	            CP 0Ah
816B: 2004    	            JR NZ,NOTLF
              	            ; LF : go to crlf routine
816D: E1      	            POP HL
816E: C36D82  	            JP CRLF
              	
8171:         	NOTLF:     ; have to test backspace ?
8171: 21F6FF  	            LD HL,LCDCONTROL2
8174: CB46    	            BIT LC2BIT_NOBS,(HL)
8176: 2011    	            JR NZ,NOTBS
              	            ; do not ignore BS
8178: FE08    	            CP 08h
817A: 200D    	            JR NZ,NOTBS
              	            ; back one char
817C: 3AF2FF  	            LD A,(LCDPOSX)
817F: B7      	            OR A                ; zero?
8180: E1      	            POP HL              ; restore HL now
8181: C8      	            RET Z               ; yes: already at line beginning, finished
              	            ; update position and set cursor
8182: 3D      	            DEC A
8183: 32F2FF  	            LD (LCDPOSX),A
              	            ; finish by setting cursor
8186: C34981  	            JP LCDSetCurVar 
              	
8189: C5      	NOTBS:     PUSH BC
818A: 4F      	            LD C,A              ; save char in C
818B: 3AF9FF  	            LD A,(LCDCOLS)
818E: 47      	            LD B,A
818F: 3AF2FF  	            LD A,(LCDPOSX)
8192: B8      	            CP B                ; xpos >= nbcols ?
8193: 380B    	            JR C,SENDCHAR      ; no, ok to send character
              	            ; at the end of line, check if we wrap
8195: CD6582  	            CALL TESTWRAP
8198: 2003    	            JR NZ,DOWRAP 
              	            ; no wrap : finished
819A: C1      	            POP BC
819B: E1      	            POP HL
819C: C9      	            RET
              	
819D: CD6D82  	DOWRAP:    CALL CRLF
              	
81A0: 79      	SENDCHAR:  LD A,C
81A1: CD0A83  	            CALL fLCD_Data      ; send byte
              	            ; Compute RAM copy address
81A4: 21A2FF  	            LD HL,LCD_RAMCOPY   ; base address
81A7: D5      	            PUSH DE
81A8: 3AF9FF  	            LD A,(LCDCOLS)      ; DE = width
81AB: 5F      	            LD E,A
81AC: 1600    	            LD D,0
81AE: 3AF3FF  	            LD A,(LCDPOSY)      ; 0 to 3
81B1: B7      	ADDLINE:   OR A                ; A nul?
81B2: 2804    	            JR Z,STORE
81B4: 19      	            ADD HL,DE
81B5: 3D      	            DEC A
81B6: 18F9    	            JR ADDLINE
81B8: 3AF2FF  	STORE:      LD A,(LCDPOSX)
81BB: 5F      	            LD E,A
81BC: 19      	            ADD HL,DE           ; addresss ready
81BD: 71      	            LD (HL),C           ; store character
              	            ;update x pos
81BE: 3AF2FF  	            LD A,(LCDPOSX)
81C1: 3C      	            INC A
81C2: 32F2FF  	            LD (LCDPOSX),A
              	
81C5: D1      	            POP DE
81C6: C1      	            POP BC
81C7: E1      	            POP HL                    
81C8: C9      	            RET
              	
              	;---------------------------------------------------------------------------
              	; LCDString : Output character string to LCD. 
              	;---------------------------------------------------------------------------
              	; The character string is taken at the adress following the CALL and ends with 0.
              	; The routine returns to the address after the string.
              	;   On entry: - (SP already points to the start of the string)
              	;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
81C9:         	LCDString:
81C9: E3      	            EX   (SP),HL        ;Save HL and get the return address
81CA: F5      	            PUSH  AF
81CB: C5      	            PUSH  BC
81CC: D5      	            PUSH    DE
81CD: 7E      	NextCh:       LD   A,(HL)         ;Read next character 
81CE: B7      	            OR      A
81CF: 2806    	            JR  Z,EndString          ;ends with a 0
81D1: CD6181  	            CALL    LCDChar     ;Write character to display
81D4: 23      	            INC  HL
81D5: 18F6    	            JR  NextCh
81D7: 23      	EndString:       INC  HL             ;jump over the ending 0
81D8: D1      	            POP     DE
81D9: C1      	            POP  BC
81DA: F1      	            POP  AF
81DB: E3      	            EX   (SP),HL        ;restore HL and new return address
81DC: C9      	            RET
              	
              	
              	;---------------------------------------------------------------------------
              	; LCDClear : Clears LCD screen 
              	;---------------------------------------------------------------------------
81DD: F5      	LCDClear:   PUSH AF
81DE: C5      	            PUSH BC
81DF: E5      	            PUSH HL
81E0: AF      	            XOR A               ; clear RAM screen copy
81E1: 0650    	            LD B,80
81E3: 21A2FF  	            LD HL,LCD_RAMCOPY
81E6: 77      	ZERORAM:   LD (HL),A
81E7: 23      	            INC HL
81E8: 10FC    	            DJNZ ZERORAM
              	            ; now clear LCD
              	            ; Display Clear
81EA: 3E01    	            LD   A, 0b00000001  ;Control reg:  0  0  0  0  0  0  0  1
81EC: CDCF82  	            CALL fLCD_Inst      ;Clear display
              	            ; cursor at 0,0
81EF: 010000  	            LD BC,0
81F2: CD2781  	            CALL LCDSetCur
81F5: E1      	            POP HL
81F6: D1      	            POP DE
81F7: F1      	            POP AF
              	
              	;---------------------------------------------------------------------------
              	; LCDScrollUp : scrolls the LCD one line up and clears bottom line
              	;---------------------------------------------------------------------------
81F8:         	LCDScrollUp:
              	#local    
81F8: E5      	            PUSH HL
81F9: D5      	            PUSH DE
81FA: C5      	            PUSH BC
81FB: F5      	            PUSH AF
81FC: 3AF9FF  	            LD A,(LCDCOLS)
81FF: 2E00    	            LD L,0
8201: 2600    	            LD H,0              ; HL = 0
8203: 5F      	            LD E,A
8204: 1600    	            LD D,0              ; DE = 20
8206: 3AFAFF  	            LD A,(LCDROWS)      ; A = 4
8209: 3D      	            DEC A               ; A = 3
820A: 47      	            LD B,A              ; B = 3
820B: 19      	ADDWIDTH:  ADD HL,DE           ; HL = 20, 40, 60
820C: 10FD    	            DJNZ ADDWIDTH
820E: E5      	            PUSH HL             ; push 60
820F: 11A2FF  	            LD DE,LCD_RAMCOPY   ; DE = source
8212: 21A2FF  	            LD HL,LCD_RAMCOPY   ; HL = source
8215: 3AF9FF  	            LD A,(LCDCOLS)      ; A = 20
8218: 4F      	            LD C,A
8219: 0600    	            LD B,0              ; BC = 20
821B: 09      	            ADD HL,BC           ; HL = source + 20
821C: C1      	            POP BC              ; BC = 60
821D: EDB0    	            LDIR                ; transfer the 60 bytes
821F: 3AF9FF  	            LD A,(LCDCOLS)
8222: 47      	            LD B,A              ; B = 20
8223: 3E20    	            LD A,' '            ; space character
8225: D5      	            PUSH DE
8226: E1      	            POP HL              ; HL = source+60
8227: 77      	NEXTCHAR:   LD (HL),A           ; store a space
8228: 23      	            INC HL
8229: 10FC    	            DJNZ NEXTCHAR
              	            ; ram copy scrolled and last line is full space
822B: CD3382  	            CALL FULLCOPY       ; and send full content to LCD
822E: F1      	            POP AF
822F: C1      	            POP BC
8230: D1      	            POP DE
8231: E1      	            POP HL
8232: C9      	            RET
              	#endlocal
              	
              	;---------------------------------------------------------------------------
              	; Utility routines
              	;---------------------------------------------------------------------------
              	; Copy ram image to LCD memory
8233:         	FULLCOPY:   
              	#local
8233: E5      	            PUSH HL
8234: C5      	            PUSH BC
8235: F5      	            PUSH AF
8236: 010000  	            LD BC,0
8239: CD2781  	            CALL LCDSetCur
823C: AF      	            XOR A
823D: 32F4FF  	            LD (CURLINE),A
8240: 21A2FF  	            LD HL,LCD_RAMCOPY
8243: 3AFAFF  	            LD A,(LCDROWS)
8246: 47      	            LD B,A              ; B = number of lines
              	
8247: C5      	NEXTLINE:  PUSH BC             ; start current line for 20 characters
8248: 3AF9FF  	            LD A,(LCDCOLS)
824B: 47      	            LD B,A              ; B = number of cols
              	
824C: 7E      	NEXTCHAR:  LD A,(HL)           ; get current character
824D: CD6181  	            CALL LCDChar        ; send it to LCD
8250: 23      	            INC HL              ; advance source
8251: 10F9    	            DJNZ NEXTCHAR      ; go next character on line
              	            ; set cursor to next line
8253: 3AF4FF  	            LD A,(CURLINE)
8256: 3C      	            INC A
8257: 32F4FF  	            LD (CURLINE),A      ; next line number
825A: 4F      	            LD C,A
825B: CD2781  	            CALL LCDSetCur      ; set to Y,0
825E: C1      	            POP BC              ; get back current line number
825F: 10E6    	            DJNZ NEXTLINE
              	            ;we're done
8261: F1      	            POP AF
8262: C1      	            POP BC
8263: E1      	            POP HL
8264: C9      	            RET
              	#endlocal
              	
              	; Test wrap control bit, sets Z if no wrapping
8265: E5      	TESTWRAP:   PUSH HL
8266: 21F5FF  	            LD HL,LCDCONTROL
8269: CB56    	            BIT LCBIT_WRAP,(HL)
826B: E1      	            POP HL
826C: C9      	            RET
              	
              	; back to beginning of line
826D: F5      	CRLF:       PUSH AF
826E: E5      	            PUSH HL
826F: AF      	            XOR A
8270: 32F2FF  	            LD (LCDPOSX),A      ; 0 => X
8273: 21F3FF  	            LD HL,LCDPOSY       ; Y = 0-3
8276: 3AFAFF  	            LD A,(LCDROWS)      ; 3
8279: 3D      	            DEC A               ; 2
827A: BE      	            CP (HL)             ; 2 >= Y? => NC
827B: 3005    	            JR NC,INCRY        ; ok to increment Y
              	            ; lock Y at 3, and scroll up
827D: E1      	            POP HL
827E: F1      	            POP AF
827F: C3F881  	            JP LCDScrollUp
8282: 34      	INCRY:     INC (HL)
8283: E1      	            POP HL
8284: F1      	            POP AF
8285: C9      	            RET                    
              	            
              	            INCLUDE    "Alphanumeric_LCD_I2C.asm"
              	; **********************************************************************
              	; **  Alphanumeric LCD support                  by Stephen C Cousins  **
              	; **********************************************************************
              	;
              	; **  Written as a Small Computer Monitor App 
              	; **  Version 0.1 SCC 2018-05-16
              	; **  www.scc.me.uk
              	;
              	; Ported to I2C by Francis Pierot 2020-05-13
              	; **********************************************************************
              	;
              	; This module provides support for alphanumeric LCD modules using with
              	; *  HD44780 (or compatible) controller
              	; *  5 x 7 pixel fonts
              	; *  Up to 80 characters in total (eg. 4 lines of 20 characters)
              	; *  I2C Interface
              	;
              	; The I2C adapter uses 4-bit mode and generally has an 8574T with: 
              	; Bits 0 to 2  driving  Rs, R/W and E LCD pins, bit 3 controlling 
              	; backlight on/off, and bits 4 to 7 driving P4 to P7 pins.
              	;
              	; LCD module pinout:
              	;   1  Vss   0v supply
              	;   2  Vdd   5v supply
              	;   3  Vo    LCD input voltage (near zero volts via potentiometer)
              	;   4  RS    High = data, Low = instruction
              	;   5  R/W   High = Read, Low = Write
              	;   6  E     Enable signal (active high)
              	;   7  DB0   Data bit 0
              	;   8  DB1   Data bit 1
              	;   9  DB2   Data bit 2
              	;  10  DB3   Data bit 3
              	;  11  DB4   Data bit 4
              	;  12  DB5   Data bit 5
              	;  13  DB6   Data bit 6
              	;  14  DB7   Data bit 7
              	;  15  A     Backlight anode (+)
              	;  16  K     Backlight cathode (-)
              	;
              	; The interfacing method is always 4-bit data mode and uses time delays
              	; rather than polling the display's ready status. As a result the 
              	; interface only requires 6 simple output lines:
              	;   LCD E   = Microcomputer output port bit <kLCDBitE>
              	;   LCD RS  = Microcomputer output port bit <kLCDBitRS>
              	;   LCD DB4 = Microcomputer output port bit 4
              	;   LCD DB5 = Microcomputer output port bit 5
              	;   LCD DB6 = Microcomputer output port bit 6
              	;   LCD DB7 = Microcomputer output port bit 7
              	; Display's R/W is connected to 0v so it is always in write mode
              	; All 6 connections must be on the same port address <kLCDPrt>
              	; This method also allows a decent length of cable from micro to LCD
              	;
              	; **********************************************************************
              	;
              	; To include the code for any given function provided by this module, 
              	; add the appropriate #REQUIRES <FunctionName> statement at the top of 
              	; the parent source file.
              	; For example:  #REQUIRES   uHexPrefix
              	;
              	; Also #INCLUDE this file at some point after the #REQUIRES statements
              	; in the parent source file.
              	; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm
              	;
              	; These are the function names provided by this module:
              	; fLCD_Init                     ;Initialise LCD
              	; fLCD_Inst                     ;Send instruction to LCD
              	; fLCD_Data                     ;Send data byte to LCD
              	; fLCD_Pos                      ;Position cursor
              	; fLCD_Str                      ;Display string
              	; fLCD_Def                      ;Define custom character
              	;
              	; **********************************************************************
              	
              	; **********************************************************************
              	; **  Constants
              	; **********************************************************************
              	
              	; Constants that must be defined externally
              	;kLCDPrt:   .EQU 0x18           ;Port address used for LCD
              	;kLCDBitRS: .EQU 2              ;Port bit for LCD RS signal
              	;kLCDBitE:  .EQU 3              ;Port bit for LCD E signal
              	;kLCDWidth: .EQU 20             ;Width in characters
              	
              	; Cursor position values for the start of each line
0000:         	kLCD_Line1: .EQU 0x00 
0040:         	kLCD_Line2: .EQU 0x40 
0014:         	kLCD_Line3: .EQU kLCD_Line1+kLCDWidth
0054:         	kLCD_Line4: .EQU kLCD_Line2+kLCDWidth 
              	
              	; Instructions to send as A register to fLCD_Inst
0001:         	kLCD_Clear: .EQU 0b00000001     ;LCD clear
0008:         	kLCD_Off:   .EQU 0b00001000     ;LCD off
000C:         	kLCD_On:    .EQU 0b00001100     ;LCD on, no cursor or blink
000E:         	kLCD_Under: .EQU 0b00001110     ;LCD on, cursor = underscore
000D:         	kLCD_Blink: .EQU 0b00001101     ;LCD on, cursor = blink block
000F:         	kLCD_Both:  .EQU 0b00001111     ;LCD on, cursor = under+blink
              	
              	; Constants used by this code module
              	;kLCD_Clr:  .EQU 0b00000001     ;LCD command: Clear display
0080:         	kLCD_Pos:   .EQU 0b10000000     ;LCD command: Position cursor
0040:         	kLCD_Def:   .EQU 0b01000000     ;LCD command: Define character
              	
              	
              	; **********************************************************************
              	; **  Program code
              	; **********************************************************************
              	
              	#CODE _CODE
              	
              	; **********************************************************************
              	; **  LCD support functions
              	; **********************************************************************
              	
              	; Initialise alphanumeric LCD module
              	; LCD control register codes:
              	;   DL   0 = 4-bit mode        1 = 8-bit mode
              	;   N    0 = 1-line mode       1 = 2-line mode
              	;   F    0 = Font 5 x 8        1 = Font 5 x 11
              	;   D    0 = Display off       1 = Display on
              	;   C    0 = Cursor off        1 = Cursor on
              	;   B    0 = Blinking off      1 = Blinking on
              	;   ID   0 = Decrement mode    1 = Increment mode
              	;   SH   0 = Entire shift off  1 = Entire shift on
8286:         	fLCD_Init:              
              	            ; close I2C by sending stop
8286: 3EC0    	            LD   A,0b11000000   ;SCL and SDA high ->  STOP
8288: 32A1FF  	            LD   (LCD_BLIGHT),A ;put a non null value in backlighting flag
828B: CDDA80  	            CALL I2C_WrPort     ;SCL high and SDA high
              	            
              	            ; official LCD init
828E: 3E28    	            LD   A, 40
8290: CD9C83  	            CALL LCDDelay       ;Delay 40ms after power up
              	                        
8293: 3E4E    	            LD   A,I2C_ADDR     ;I2C address to write to
8295: CD6680  	            CALL I2C_Open       ;Open I2C device for write
8298: C0      	            RET  NZ
              	
              	; For reliable reset set 8-bit mode - 3 times
8299: CD8183  	            CALL WrFn8bit       ;Function = 8-bit mode
829C: CD8183  	            CALL WrFn8bit       ;Function = 8-bit mode
829F: CD8183  	            CALL WrFn8bit       ;Function = 8-bit mode
              	; Set 4-bit mode
82A2: CD7D83  	            CALL WrFn4bit       ;Function = 4-bit mode
82A5: CD9A83  	            CALL LCDDelay1      ;Delay 37 us or more
              	            
82A8: CD6D80  	            CALL I2C_Close
              	            
              	; Function set
82AB: 3E28    	            LD   A, 0b00101000  ;Control reg:  0  0  1  DL N  F  x  x
82AD: CDCF82  	            CALL fLCD_Inst      ;4-bit, 2 lines, 5x8
              	; Display On/Off control
82B0: 3E0F    	            LD   A, 0b00001111  ;Control reg:  0  0  0  0  1  D  C  B 
82B2: CDCF82  	            CALL fLCD_Inst      ;Display on, cursor on, blink on
              	; Entry mode
82B5: 3E06    	            LD   A, 0b00000110  ;Control reg:  0  0  0  0  0  1  ID SH
82B7: CDCF82  	            CALL fLCD_Inst      ;Increment mode, shift off           
              	; Display Clear
82BA: 3E01    	            LD   A, 0b00000001  ;Control reg:  0  0  0  0  0  0  0  1
82BC: CDCF82  	            CALL fLCD_Inst      ;Clear display
82BF: C9      	            RET
              	
              	
              	; Set or reset backlighting bit in A
              	;  On entry: A = 4-bit byte, (LCD_BLIGHT) = 0 to switch off, 1 to switch on
              	;  On exit: bit set or reset in A
82C0: F5      	SetA_Light: PUSH AF
82C1: 3AA1FF  	            LD   A,(LCD_BLIGHT)
82C4: B7      	            OR   A
82C5: 2804    	            JR   Z, ResetLight
82C7: F1      	            POP  AF
82C8: CBDF    	            SET  kLCDBitBL, A
82CA: C9      	            RET
82CB: F1      	ResetLight:     POP  AF
82CC: CB9F    	            RES  kLCDBitBL, A
82CE: C9      	            RET
              	
              	; Write instruction to LCD
              	;   On entry: A = Instruction byte to be written
              	;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
82CF: C5      	fLCD_Inst:  PUSH BC
82D0: D5      	            PUSH DE
82D1: F5      	            PUSH AF
82D2: 3E4E    	            LD   A,I2C_ADDR     ;I2C address to write to
82D4: CD6680  	            CALL I2C_Open       ;Open I2C device for write
82D7: 2016    	            JR   NZ,EndInst
82D9: F1      	            POP  AF
82DA: F5      	            PUSH AF
82DB: F5      	            PUSH AF
82DC: CDF382  	            CALL Wr4bitsI       ;Write bits 4 to 7 of instruction
82DF: F1      	            POP  AF
82E0: 17      	            RLA                 ;Rotate bits 0-3 into bits 4-7...
82E1: 17      	            RLA
82E2: 17      	            RLA
82E3: 17      	            RLA
82E4: CDF382  	            CALL Wr4bitsI       ;Write bits 0 to 3 of instruction
82E7: 3E02    	            LD   A, 2
82E9: CD9C83  	            CALL LCDDelay       ;Delay 2 ms to complete 
82EC: CD6D80  	            CALL I2C_Close
82EF: F1      	EndInst:       POP  AF
82F0: D1      	            POP  DE
82F1: C1      	            POP  BC
82F2: C9      	            RET
82F3: E6F0    	Wr4bitsI:   AND  0xF0           ;Mask so we only have D4 to D7
82F5: CDC082  	            CALL SetA_Light     ; set or reset backlighting bit
82F8: F5      	            PUSH AF
82F9: CD6F80  	            CALL I2C_Write      ;Output with E=Low and RS=Low
82FC: F1      	            POP  AF
82FD: F5      	            PUSH AF
82FE: CBD7    	            SET  kLCDBitE, A
8300: CD6F80  	            CALL I2C_Write      ;Output with E=High and RS=Low
8303: F1      	            POP  AF
8304: CB97    	            RES  kLCDBitE, A
8306: CD6F80  	            CALL I2C_Write      ;Output with E=Low and RS=Low
8309: C9      	            RET
              	
              	
              	; Write data to LCD
              	;   On entry: A = Data byte to be written
              	;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
830A: C5      	fLCD_Data:  PUSH BC
830B: D5      	            PUSH DE
830C: F5      	            PUSH AF
830D: 3E4E    	            LD   A,I2C_ADDR     ;I2C address to write to
830F: CD6680  	            CALL I2C_Open       ;Open I2C device for write
8312: 2016    	            JR   NZ,EndData
8314: F1      	            POP  AF
8315: F5      	            PUSH AF
8316: F5      	            PUSH AF             ; push a second time
8317: CD2E83  	            CALL Wr4bitsD       ;Write bits 4 to 7 of data byte
831A: F1      	            POP  AF
831B: 17      	            RLA                 ;Rotate bits 0-3 into bits 4-7...
831C: 17      	            RLA
831D: 17      	            RLA
831E: 17      	            RLA
831F: CD2E83  	            CALL Wr4bitsD       ;Write bits 0 to 3 of data byte
8322: 3E96    	            LD   A, 150
8324: 3D      	Wait:      DEC  A              ;Wait a while to allow data 
8325: 20FD    	            JR   NZ, Wait      ;  write to complete
8327: CD6D80  	            CALL I2C_Close
832A: F1      	EndData:       POP  AF
832B: D1      	            POP  DE
832C: C1      	            POP  BC
832D: C9      	            RET
832E: E6F0    	Wr4bitsD:   AND  0xF0           ;Mask so we only have D4 to D7
8330: CDC082  	            CALL SetA_Light     ; set or reset backlighting bit
8333: CBC7    	            SET  kLCDBitRS, A
8335: F5      	            PUSH AF
8336: CD6F80  	            CALL I2C_Write      ;Output with E=Low and RS=High
8339: F1      	            POP  AF
833A: F5      	            PUSH AF
833B: CBD7    	            SET  kLCDBitE, A
833D: CD6F80  	            CALL I2C_Write      ;Output with E=High and RS=High
8340: F1      	            POP  AF
8341: CB97    	            RES  kLCDBitE, A
8343: F5      	            PUSH AF
8344: CD6F80  	            CALL I2C_Write      ;Output with E=Low and RS=High
8347: F1      	            POP  AF
8348: CB87    	            RES  kLCDBitRS, A
834A: CD6F80  	            CALL I2C_Write      ;Output with E=Low and RS=Low
834D: C9      	            RET
              	
              	
              	; Position cursor to specified location
              	;   On entry: A = Cursor position
              	;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
834E: F5      	fLCD_Pos:   PUSH AF
834F: F680    	            OR   kLCD_Pos       ;Prepare position cursor instruction
8351: CDCF82  	            CALL fLCD_Inst      ;Write instruction to LCD
8354: F1      	            POP  AF
8355: C9      	            RET
              	
              	
              	; Output text string to LCD
              	;   On entry: DE = Pointer to null terminated text string
              	;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved
8356: 1A      	fLCD_Str:   LD   A, (DE)        ;Get character from string
8357: B7      	            OR   A              ;Null terminator?
8358: C8      	            RET  Z              ;Yes, so finished
8359: D5      	            PUSH DE             ;i2c write looses DE
835A: CD0A83  	            CALL fLCD_Data      ;Write character to display
835D: D1      	            POP  DE
835E: 13      	            INC  DE             ;Point to next character
835F: 18F5    	            JR   fLCD_Str       ;Repeat
              	
              	#IF USE_LCDPRINT
              	; Output character string to LCD.
              	; The character string is taken at the adress following the CALL and ends with 0.
              	; The routine returns to the address after the string.
              	;   On entry: - (SP already points to the start of the string)
              	;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
              	fLCD_Print:
              	            EX 		(SP),HL 		;Save HL and get the return address
              	            PUSH 	AF
              	            PUSH 	BC
              	            PUSH    DE
              	NextPrint:      LD 		A,(HL)          ;Read next character 
              	            OR      A
              	            JR		Z,EndPrint          ;ends with a 0
              	            CALL    fLCD_Data       ;Write character to display
              	            INC 	HL
              	            JR		NextPrint
              	EndPrint:       INC 	HL 				;jump over the ending 0
              	            POP     DE
              	            POP 	BC
              	            POP 	AF
              	            EX 		(SP),HL 		;restore HL and new return address
              	            RET
              	#ENDIF
              	
              	; Define custom character
              	;   On entry: A = Character number (0 to 7)
              	;             DE = Pointer to character bitmap data
              	;   On exit:  A = Next character number
              	;             DE = Next location following bitmap
              	;             BC HL IX IY I AF' BC' DE' HL' preserved
              	; Character is 
8361: C5      	fLCD_Def:   PUSH BC
8362: F5      	            PUSH AF
8363: 07      	            RLCA                ;Calculate location
8364: 07      	            RLCA                ;  for bitmap data
8365: 07      	            RLCA                ;  = 8 x CharacterNumber
8366: F640    	            OR   kLCD_Def       ;Prepare define character instruction
8368: CDCF82  	            CALL fLCD_Inst      ;Write instruction to LCD
836B: 0600    	            LD   B, 0
836D: 1A      	LoopDef:      LD   A, (DE)        ;Get byte from bitmap
836E: D5      	            PUSH DE
836F: CD0A83  	            CALL fLCD_Data      ;Write byte to display
8372: D1      	            POP  DE
8373: 13      	            INC  DE             ;Point to next byte
8374: 04      	            INC  B              ;Count bytes
8375: CB58    	            BIT  3, B           ;Finish all 8 bytes?
8377: 28F4    	            JR   Z, LoopDef       ;No, so repeat
8379: F1      	            POP  AF
837A: 3C      	            INC  A              ;Increment character number
837B: C1      	            POP  BC
837C: C9      	            RET
              	
              	
              	; **********************************************************************
              	; **  Private functions
              	; **********************************************************************
              	
              	; Write function to LCD
              	;   On entry: A = Function byte to be written
              	;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
837D: 3E20    	WrFn4bit:   LD   A, 0b00100000  ;4-bit mode
837F: 1802    	            JR   WrFunc
8381: 3E30    	WrFn8bit:   LD   A, 0b00110000  ;8-bit mode
8383: CBDF    	WrFunc:     SET kLCDBitBL, A    ; set backlighting
8385: F5      	            PUSH AF
8386: CD6F80  	            CALL I2C_Write      ;Output with E=Low and RS=Low
8389: F1      	            POP  AF
838A: F5      	            PUSH AF
838B: CBD7    	            SET  kLCDBitE, A
838D: CD6F80  	            CALL I2C_Write      ;Output with E=High and RS=Low
8390: F1      	            POP  AF
              	           ;RES  kLCDBitE, A
8391: CD6F80  	            CALL I2C_Write      ;Output with E=Low and RS=Low
8394: 3E05    	            LD   A, 5
8396: CD9C83  	            CALL LCDDelay       ;Delay 5 ms to complete
8399: C9      	            RET
              	
              	
              	; Delay in milliseconds using SCM delay API
              	;   On entry: A = Number of milliseconds delay
              	;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
839A: 3E01    	LCDDelay1:  LD   A, 1           ;Delay by 1 ms
839C: D5      	LCDDelay:   PUSH DE
839D: 5F      	            LD   E, A           ;Delay by 'A' ms
839E: 1600    	            LD   D, 0
83A0: 0E0A    	            LD   C, 0x0A        ;API 0x0A
              	;$$            RST  0x30           ;  = Delay in milliseconds
83A2: D1      	            POP  DE
83A3: C9      	            RET
              	
              	
              	; **********************************************************************
              	; **  Variables
              	; **********************************************************************
              	
              	#DATA _DATA
FFA1: 00      	LCD_BLIGHT: .DB  0  ; flag for backlighting
              	
              	            
              	#DATA   _DATA
              	           
              	; variables
FFA2: 00000000	LCD_RAMCOPY:                    .DS 80  ; 80 bytes for screen ram copy
FFA6: 00...   	LCD_RAMCOPY:                    .DS 80  ; 80 bytes for screen ram copy
FFF2: 00      	LCDPOSX:    .DB 0               ; X from 0 to 19
FFF3: 00      	LCDPOSY:    .DB 0               ; Y from 0 to 3
FFF4: 00      	CURLINE:    .DB 0               ; line number during work
              	; screen settings
FFF5: 00      	LCDCONTROL: .DB 0               ; control bits:
0000:         	LCBIT_I2C:  .EQU 0              ; 0 = I2C OFF
0001:         	LCBIT_PARALLEL:                 .EQU 1  ; 0 = PARALLEL OFF
0002:         	LCBIT_WRAP: .EQU 2              ; 0 = No wrap
0003:         	LCBIT_LCDONLY:                  .EQU 3  ; 1 = display ONLY on LCD
0004:         	LCBIT_CURSOR:                   .EQU 4  ; 1 = cursor on
0005:         	LCBIT_BLINK:                    .EQU 5  ; 1 = blinking cursor
0006:         	LCBIT_BLOCK:                    .EQU 6  ; 1 = block cursor, 0 = underscore
0007:         	LCBIT_NOLF: .EQU 7              ; 1 = do not interpret LF (0Ah)
FFF6: 00      	LCDCONTROL2:                    .DB 0  
0000:         	LC2BIT_NOBS:                    .EQU 0  ; 1 = do not interpret BS (08h) 
FFF7: 00      	LCDPORT:    .DB 0               ; 0x0C  on SC126 I2C
FFF8: 00      	I2CDEVICE:  .DB 0               ; 0x27 for 8574T controllers
FFF9: 00      	LCDCOLS:    .DB 0               ; 20 columns
FFFA: 00      	LCDROWS:    .DB 0               ; 4 lines
FFFB: 00000000	LCD_INDEX:  .DB 0,0,0,0         ; each line offset
              	
              	
              	
              	
              	            .END
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	


; +++ segments +++

#CODE _BOOT    = $0000 =     0,  size = $0011 =    17
#DATA _DATA    = $FFA0 = 65440,  size = $005F =    95
#CODE _CODE    = $8000 = 32768,  size = $03A4 =   932

; +++ global symbols +++

ADDLINE        = $81B1 = 33201  _CODE   LCDConsole.asm:161
BitMaps        = $8056 = 32854  _CODE   Source.asm:113
Bit_Clk        = $807E = 32894  _CODE   I2C.asm:108
Bit_Hi         = $807B = 32891  _CODE   I2C.asm:107
CRLF           = $826D = 33389  _CODE   LCDConsole.asm:322
CURLINE        = $FFF4 = 65524  _DATA   LCDConsole.asm:348
DOWRAP         = $819D = 33181  _CODE   LCDConsole.asm:150
EndData        = $832A = 33578  _CODE   Alphanumeric_LCD_I2C.asm:240
EndInst        = $82EF = 33519  _CODE   Alphanumeric_LCD_I2C.asm:199
EndString      = $81D7 = 33239  _CODE   LCDConsole.asm:198
FULLCOPY       = $8233 = 33331  _CODE   LCDConsole.asm:278
I2CDEVICE      = $FFF8 = 65528  _DATA   LCDConsole.asm:362
I2C_ADDR       = $004E =    78  _CODE   Source.asm:60
I2C_Close      = $806D = 32877  _CODE   I2C.asm:89
I2C_Open       = $8066 = 32870  _CODE   I2C.asm:76
I2C_PORT       = $000C =    12  _CODE   Source.asm:56
I2C_RAMCPY     = $FFA0 = 65440  _DATA   I2C.asm:236
I2C_RdPort     = $80E6 = 32998  _CODE   I2C.asm:225
I2C_SCL_HI     = $80C0 = 32960  _CODE   I2C.asm:193
I2C_SCL_LO     = $80C7 = 32967  _CODE   I2C.asm:197
I2C_SCL_WR     = $0000 =     0  _CODE   Source.asm:58
I2C_SDA_HI     = $80CE = 32974  _CODE   I2C.asm:201
I2C_SDA_LO     = $80D5 = 32981  _CODE   I2C.asm:205
I2C_SDA_RD     = $0007 =     7  _CODE   Source.asm:59
I2C_SDA_WR     = $0007 =     7  _CODE   Source.asm:57
I2C_Start      = $80A6 = 32934  _CODE   I2C.asm:167
I2C_Stop       = $80B3 = 32947  _CODE   I2C.asm:180
I2C_WrPort     = $80DA = 32986  _CODE   I2C.asm:213
I2C_Write      = $806F = 32879  _CODE   I2C.asm:101
INCRY          = $8282 = 33410  _CODE   LCDConsole.asm:335
LC2BIT_NOBS    = $0000 =     0  _DATA   LCDConsole.asm:360
LCBIT_BLINK    = $0005 =     5  _DATA   LCDConsole.asm:356 (unused)
LCBIT_BLOCK    = $0006 =     6  _DATA   LCDConsole.asm:357 (unused)
LCBIT_CURSOR   = $0004 =     4  _DATA   LCDConsole.asm:355
LCBIT_I2C      = $0000 =     0  _DATA   LCDConsole.asm:351
LCBIT_LCDONLY  = $0003 =     3  _DATA   LCDConsole.asm:354 (unused)
LCBIT_NOLF     = $0007 =     7  _DATA   LCDConsole.asm:358
LCBIT_PARALLEL = $0001 =     1  _DATA   LCDConsole.asm:352 (unused)
LCBIT_WRAP     = $0002 =     2  _DATA   LCDConsole.asm:353
LCDCOLS        = $FFF9 = 65529  _DATA   LCDConsole.asm:363
LCDCONTROL     = $FFF5 = 65525  _DATA   LCDConsole.asm:350
LCDCONTROL2    = $FFF6 = 65526  _DATA   LCDConsole.asm:359
LCDChar        = $8161 = 33121  _CODE   LCDConsole.asm:105
LCDClear       = $81DD = 33245  _CODE   LCDConsole.asm:209
LCDConsoleInit = $80EF = 33007  _CODE   LCDConsole.asm:11
LCDDelay       = $839C = 33692  _CODE   Alphanumeric_LCD_I2C.asm:368
LCDDelay1      = $839A = 33690  _CODE   Alphanumeric_LCD_I2C.asm:367
LCDPORT        = $FFF7 = 65527  _DATA   LCDConsole.asm:361
LCDPOSX        = $FFF2 = 65522  _DATA   LCDConsole.asm:346
LCDPOSY        = $FFF3 = 65523  _DATA   LCDConsole.asm:347
LCDROWS        = $FFFA = 65530  _DATA   LCDConsole.asm:364
LCDScrollUp    = $81F8 = 33272  _CODE   LCDConsole.asm:232
LCDSetCur      = $8127 = 33063  _CODE   LCDConsole.asm:56
LCDSetCurVar   = $8149 = 33097  _CODE   LCDConsole.asm:78
LCDString      = $81C9 = 33225  _CODE   LCDConsole.asm:187
LCD_BLIGHT     = $FFA1 = 65441  _DATA   Alphanumeric_LCD_I2C.asm:382
LCD_INDEX      = $FFFB = 65531  _DATA   LCDConsole.asm:365
LCD_RAMCOPY    = $FFA2 = 65442  _DATA   LCDConsole.asm:345
LoopDef        = $836D = 33645  _CODE   Alphanumeric_LCD_I2C.asm:325
NOTBS          = $8189 = 33161  _CODE   LCDConsole.asm:135
NOTLF          = $8171 = 33137  _CODE   LCDConsole.asm:117
NextCh         = $81CD = 33229  _CODE   LCDConsole.asm:192
NoAck          = $8099 = 32921  _CODE   I2C.asm:124
PROGRAMSTART   = $8000 = 32768  _CODE   Source.asm:70
ResetLight     = $82CB = 33483  _CODE   Alphanumeric_LCD_I2C.asm:173
SENDCHAR       = $81A0 = 33184  _CODE   LCDConsole.asm:152
STORE          = $81B8 = 33208  _CODE   LCDConsole.asm:166
SetA_Light     = $82C0 = 33472  _CODE   Alphanumeric_LCD_I2C.asm:166
TESTWRAP       = $8265 = 33381  _CODE   LCDConsole.asm:315
USE_I2CREAD    = $0000 =     0  _CODE   Source.asm:53
USE_LCDPRINT   = $0000 =     0  _CODE   Source.asm:54
Wait           = $8324 = 33572  _CODE   Alphanumeric_LCD_I2C.asm:237
Wr4bitsD       = $832E = 33582  _CODE   Alphanumeric_LCD_I2C.asm:244
Wr4bitsI       = $82F3 = 33523  _CODE   Alphanumeric_LCD_I2C.asm:203
WrFn4bit       = $837D = 33661  _CODE   Alphanumeric_LCD_I2C.asm:346
WrFn8bit       = $8381 = 33665  _CODE   Alphanumeric_LCD_I2C.asm:348
WrFunc         = $8383 = 33667  _CODE   Alphanumeric_LCD_I2C.asm:349
Wr_Loop        = $8072 = 32882  _CODE   I2C.asm:103
XNOTOK         = $8130 = 33072  _CODE   LCDConsole.asm:61
XOK            = $8132 = 33074  _CODE   LCDConsole.asm:63
YNOTOK         = $813E = 33086  _CODE   LCDConsole.asm:69
YOK            = $8140 = 33088  _CODE   LCDConsole.asm:71
ZERORAM        = $81E6 = 33254  _CODE   LCDConsole.asm:215
_BOOT          = $0000 =     0  _BOOT   Source.asm:30 (unused)
_BOOT_end      = $0011 =    17  _BOOT   Source.asm:30 (unused)
_BOOT_size     = $0011 =    17  _BOOT   Source.asm:30
_CODE          = $8000 = 32768  _CODE   Source.asm:48
_CODE_end      = $83A4 = 33700  _CODE   Source.asm:48 (unused)
_CODE_size     = $03A4 =   932  _CODE   Source.asm:48
_DATA          = $FFA0 = 65440  _DATA   Source.asm:45 (unused)
_DATA_end      = $FFFF = 65535  _DATA   Source.asm:45 (unused)
_DATA_size     = $005F =    95  _DATA   Source.asm:45
_z180_         = $0001 =     1          :1 (unused)
fLCD_Data      = $830A = 33546  _CODE   Alphanumeric_LCD_I2C.asm:220
fLCD_Def       = $8361 = 33633  _CODE   Alphanumeric_LCD_I2C.asm:317
fLCD_Init      = $8286 = 33414  _CODE   Alphanumeric_LCD_I2C.asm:124
fLCD_Inst      = $82CF = 33487  _CODE   Alphanumeric_LCD_I2C.asm:180
fLCD_Pos       = $834E = 33614  _CODE   Alphanumeric_LCD_I2C.asm:266
fLCD_Str       = $8356 = 33622  _CODE   Alphanumeric_LCD_I2C.asm:276
kLCDBitBL      = $0003 =     3  _CODE   Source.asm:66
kLCDBitE       = $0002 =     2  _CODE   Source.asm:65
kLCDBitRS      = $0000 =     0  _CODE   Source.asm:63
kLCDBitRW      = $0001 =     1  _CODE   Source.asm:64 (unused)
kLCDWidth      = $0014 =    20  _CODE   Source.asm:67
kLCD_Blink     = $000D =    13  _CODE   Alphanumeric_LCD_I2C.asm:95 (unused)
kLCD_Both      = $000F =    15  _CODE   Alphanumeric_LCD_I2C.asm:96 (unused)
kLCD_Clear     = $0001 =     1  _CODE   Alphanumeric_LCD_I2C.asm:91 (unused)
kLCD_Def       = $0040 =    64  _CODE   Alphanumeric_LCD_I2C.asm:101
kLCD_Line1     = $0000 =     0  _CODE   Alphanumeric_LCD_I2C.asm:85
kLCD_Line2     = $0040 =    64  _CODE   Alphanumeric_LCD_I2C.asm:86
kLCD_Line3     = $0014 =    20  _CODE   Alphanumeric_LCD_I2C.asm:87 (unused)
kLCD_Line4     = $0054 =    84  _CODE   Alphanumeric_LCD_I2C.asm:88 (unused)
kLCD_Off       = $0008 =     8  _CODE   Alphanumeric_LCD_I2C.asm:92 (unused)
kLCD_On        = $000C =    12  _CODE   Alphanumeric_LCD_I2C.asm:93 (unused)
kLCD_Pos       = $0080 =   128  _CODE   Alphanumeric_LCD_I2C.asm:100
kLCD_Under     = $000E =    14  _CODE   Alphanumeric_LCD_I2C.asm:94 (unused)
stack_top      = $FFA0 = 65440  _BOOT   Source.asm:43 (unused)

; +++ local symbols +++

DefLoop = $800A = 32778  _CODE   Source.asm:80

; +++ local symbols +++

ADDWIDTH = $820B = 33291  _CODE   LCDConsole.asm:246
NEXTCHAR = $8227 = 33319  _CODE   LCDConsole.asm:262

; +++ local symbols +++

NEXTCHAR = $824C = 33356  _CODE   LCDConsole.asm:295
NEXTLINE = $8247 = 33351  _CODE   LCDConsole.asm:291


total time: 0.0145 sec.
no errors
