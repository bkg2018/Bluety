This MLMD template is MLMD documentation source.

MLMD ignores the introductory lines preceeding the `.languages` directive.
The empty lines before heading level 1 '#' are ignored as well.

NOTES:

- Any text before the .languages directive is NOT sent to any output files.

- The .languages directive must be placed at the beginning of a line.

- Having some content between the .languages directive and the heading level 1 is not
  conforming to Markdown conventions, but MLMD only ignores empty lines and will write
  any text before the heading level 1 into all generated files.

- The optional .numbering directive must be placed between the .languages and the
  level 1 '#' heading. It is ignored if a -numbering parameter is given
  when calling MLMD.

.languages fr,en main=en

# .((Multilingual Markdown Generator.)).fr((Générateur de Markdown Multilingue.)) MLMD

.((Default text..))
.fr((Texte français..))

.((MLMD is a PHP script which generate one or more Markdown files for a set of declared languages from one or more multilingual
markdown templates, using directives in the templates to distinguish each language parts..)).fr((MLMD est un script PHP qui génère
des fichiers Markdown dans plusieurs langues à partir de modèles multilingues, grâce à des directives placées dans les modèles
pour distinguer les parties de chaque langue..))

.((MLMD can add a Table Of Content in the generated Markdown files and number headings in all files and in tables of Content..))
.fr((MLMD peut ajouter des tables des matières et numéroter les titres dans les fichiers et les tables des matières..))

.((The user has full control over the generated languages, the table of content generation and the headings numbering..))
.fr((L'utilisateur peut contrôler les langues, la génération des tables des matières et la numérotation des titres..))

.toc title=2,".((Table Of Contents.)).fr((Sommaire.))" level=1-3 out=md

## Installation

.((MLMD consists of a main script `mlmd.php` and a few dependencies files. The script and its dependancies files can be put anywhere at user choice..)).fr((MLMD est constitué d'un script principal `mlmd.php` et de dépendances. Le script et ses dépendances peuvent être placés dans n'importe quel répertoire accessible à l'utilisateur..))

### .((PHP version.)).fr((Version PHP.))

.((MLMD has been tested with PHP 7.3 cli version..)).fr((MLMD a été testé avec PHP 7.3 CLI..))

.((To make sure PHP is accessible from a command line:.)).fr((Pour vérifier que PHP est accessible depuis une ligne de commande :.))

```code
php -v
```

.((should display:.)).fr((doit afficher :.))

```code
PHP 7.3.20 (cli) (built: Jul  9 2020 23:50:54) ( NTS )
Copyright (c) 1997-2018 The PHP Group
Zend Engine v3.3.20, Copyright (c) 1998-2018 Zend Technologies
    with Zend OPcache v7.3.20, Copyright (c) 1999-2018, by Zend Technologies
```

.((The directory where the PHP installation and its setting files lie can be displayed with `php --ini`..))
.fr((Le répertoire d'installation de PHP et de ses fichiers de configuration peut être affiché avec la commande `php --ini`..))

.((PHP 7.2 may work but have not been tested. The Multibyte extension (mb) is needed but should not imply a specific setting 
as it should be embedded in standard PHP 7.3 distributions..)).fr((PHP 7.2 peut fonctionner mais n'a pas été testé. 
L'extension MultiByte (mb) est utilisée mais ne nécessite pas de réglage particulier car elle est intégrée par défaut 
dans les distributions standards de PHP 7..))

### .((Storing.)).fr((Emplacement de.)) MLMD

.((The PHP script and its dependencies must be put in a directory with easy user access, e.g.:.))
.fr((Le script et ses dépendances doivent se situer dans un répertoire accessible à l'utilisateur, par exemple :.))

- `~/phpscripts` .((on.)).fr((sur.)) macOS/Linux
- `%HOMEDRIVE%%HOMEPATH%\phpscripts` .((on.)).fr((sur.)) Windows

.((Parameters that can be passed to the script are described in [How To Use MLMD](#how-to-use-mlmd).)).fr((Les paramètres du script sont décrits dans la partie [Utilisation de MLMD](#utilisation-de-mlmd).))

### .((Using an alias to launch MLMD.)).fr((Utilisation d'un alias pour lancer MLMD.))

.((This is optional and allows to type `mlmd` as if it were a command of the Operating System or command shell. Without aliases, the script must be launched by typing `php <your_path_to_mlmd>/mlmd.php`..)).fr((Ce qui suit est facultatif mais permet d'utiliser le script MLMD comme s'il était une commande du système d'exploitation. Sans les alias, le script doit être exécuté en tapant `php <chemin>/mlmd.php` avec le chemin où ont été stockés le script et ses dépendances..))

.((The commands detailed in the following examples must be adapted to the directory where the script has been stored..)).fr((Les commandes indiquées ci-après doivent être adaptées pour le répertoire où se situe el script..))

#### Linux / macOS / OS X

* .((The following alias command must be put in the shell startup script (most likely `~/.bashrc`, `~/.zshrc` etc):.)).fr((La commande suivante peut être placée dans le script de démarrage du shell (en général `~/.bashrc`, `~/.zshrc` etc) :.))

  ```code
  alias mlmd=php ~/phpscripts/mlmd.php
  ```

#### Windows 10

* .((A text file must be created (e.g. using NOTEPAD.EXE) containing this command line:.)).fr((Un fichier texte doit être créé - par exemple avec le Bloc Note - contenant la ligne suivante :.))

  ```code
  doskey mlmd=php %HOMEDRIVE%%HOMEPATH%\phpscripts\mlmd.php $*
  ```

* .((The file can be saved as `MLMD.CMD`or `mlmd.cmd` (letters case is ignored by Windows.) on the Desktop or any user accessible directory..)).fr((Le fichier est enregistré sous le nom `MLMD.CMD` ou `mlmd.cmd` (Windows ne différencie pas minuscules et majuscules dans les noms de fichiers.) sur le bureau ou dans n'importe quel répertoire accessible à l'utilisateur..))
* .((A shortcut to this CMD file must be created (right-click on file in Explorer, then create shortcut)..)).fr((Un raccourci vers ce fichier est créé par un clic de droite suivi de la commande *Créer un raccourci*..))
* .((The `shell:startup` directory must be opened (by hitting the *Windows* and *R* keys together and typing `shell:startup`)..)).fr((Le répertoire `shell:startup` est ouvert en tapant les touches *Windows* et *R* puis en tapant `shell:startup`..))
* .((The shortcut must be moved from its directory to this startup directory..)).fr((Le raccourci créé à l'étape précédente est déplacé vers le répertoire startup..))
* .((Windows must be restarted..)).fr((Windows doit être redémarré..))

.((From then on, the `mlmd` alias is available in any command line box as a normal command..)).fr((A partir de ce moment, l'alias `mlmd` est disponible dans les boîtes de commandes.))

.((This method may work with earlier versions of Windows but they have not been tested..)).fr((Cette méthode peut fonctionner avec des versions antérieures de Windows mais elles n'ont pas été testées..))

## .((How to Use MLMD.)).fr((Utilisation de MLMD.))

.((MLMD is run by the php interpreter and either receives parameters telling it which templates files to process, either processes all the template files it will find in the current directory from where it has been launched..)).fr((MLMD est exécuté par l'interpréteur PHP et reçoit des paramètres qui lui indiquent les fichiers à traiter ou explore le répertoire actuel et tous ses sous-répertoires pour localiser les fichiers à traiter..))

.((Optional parameters tells mlmd how to number headings or write links..)).fr((D'autres paramètres indiquent à MLMD comment numéroter les titres ou écrire les liens..))

### .((MLMD run parameters.)).fr((Paramètres d'exécution MLMD.))

.((The syntax for `mlmd.php` and its arguments is:.)).fr((La syntaxe pour `mlmd.php` et ses paramètres est la suivante :.))

.((
```code
php <path-to-mlmd>mlmd.php [-i <template_path> [...]] [-main <file_path>] [-out html|htmlold|md] [-numbering <numbering_scheme>]
```
.)).fr((
```code
php <chemin-de-mlmd>mlmd.php [-i <chemin_fichier> [...]] [-main <chemin_fichier>] [-out html|htmlold|md] [-numbering <schéma_numérotation>]
```
.))

If an alias has been set up, there's no need to explicitely call `php` or give the full path of MLMD script.

The input files can be given to the script with the `-i` parameter, or they can be found in the current directory from where the script is called if not `-i` parameter is used. This is explained in [Input files](#input-files--i).

### Templates file pathes and names

The files names for the Markdown templates must end with `.base.md` or `.mlmd` extension. Files with other extensions will be ignored. The `.base.md` extension can be convenient because syntax highlighting and Markdown previewing will work in most editors, however the MLMD templates are not actual Markdown files and do not fully conform to Markdown syntax so this can lead to some confusion. The `.mlmd` extension is more explicit and makes it clear that the files are MLMD templates rather than variants of Markdown files.

When no template files parameter (`-i`) is given to the script, MLMD will explore the directory tree where it starts and generate files for all the templates it finds and the languages declared in them. The generated files will be put in the same directory as their source template.

The `-main` parameter sets the main input file and the root directory for all relative links in the generated files: the directory of this main file will be considered as the root directory for all other files. For consistency, no other file should lie above this root directory or in a directory outside the tree under this root, so that all internal links in generated files can use relative pathes.

The various directives are described in [Directives](#directives).

### Input files: `-i` argument

To process specific files, use the `-i` parameter followed by the files pathes. To process more than one files, it is best to have them in a same tree and to start MLMD at the root directory where the main Markdown file lies so that file pathes in links can be relative to this root dir.

* Process a given file: use `-i <template_path>`:

  ```code
  php ~/phpscripts/mlmd.php -i ~/project/README.mlmd
  ```

* Process multiple files: use multiples `-i <template_path>`:

  ```code
  php ~/phpscripts/mlmd.php -i ~/project/README.mlmd -i ~/project/HOWTOUSE.mlmd
  ```

* Process a whole directory and subdirectories: change to this directory and don't give any `-i` parameter:

  ```code
  cd ~/project
  php ~/phpscripts/mlmd.php
  ```

  This syntax will process any file found in the directory tree which ends by `.base.md` or `.mlmd`, including those found in sub directories. Other files will be ignored.

  Other parameters are also allowed in this mode.

### Main file: `-main` argument

If a file is named `README.mlmd` in the directory where the script is started, it will be considered the main file of all the directory tree and all the links will use pathes relative to its directory. Notice the name casing: `README` is uppercase, while the `.mlmd` extension is lowercase. On Windows, case is not significant but the script still searches an uppercase `README`.

If there is no `README.md` file in the starting directory, the `-main` parameter can be used to tell the script which template is the main file, and indirectly which directory is the root directory:

```code
php ~/phpscripts/mlmd.php -main ./main.mlmd
```

### Output mode html/htmlold/md: `-out` argument

The `-out` parameter selects the HTML or Markdown links style in the Table Of Contents.

To distinguish the methods, here are some explanations.

Markdown allows three ways for creating links to a heading in a file:

* use standard HTML `<A>` anchors and links, using the `name` or ìd` attribute to identify anchors.
* use Markdown automatic heading targets, all lowercase with non alphanumeric chahracters deleted and spaces changed to dashes.
* use Markdown `{:` targets in headings.

The standard old style HTML `<A name="target"></A>` or modern style HTML `<A id="target"></A>` anchors and `<A href="file#target"></A>` links can be used in MLMD templates just like they would in standard HTML or Markdown The Markdown automatic links `[](#heading-text)` also works as they would in a normal Markdown: MLMD won't change the anchors and links written using these forms.

Common use standards for Markdown discourage the use of HTML, however it is perfectly valid to use HTML and HTML anchors are more versatile than Markdown links.

Still, MLMD can generate a Table Of Contents using the `.toc` directive and will put links to headings in this table.
To this aim, the `-out` parameter allows to select which method will be used for the TOC links:

* `-out htmlold` will generate `<A name="target">` HTML anchors for each headings in each processed file and `<A href="file#target">` HTML links in the table Of Contents.
* `-out html` will generate `<A id="target">` HTML anchors for each headings in each processed file and `<A href="file#target">` HTML links in the table Of Contents.
* `-out md` will generate `<A id="target">` HTML anchors for each headings in each processed file and `[](file#target)` Markdown links in the Table Of Contents.
* `-out mdpure` will generate `{#id}` Markdown anchors for each headings in each processed file and `[](file#target)` Markdown links in the Table Of Contents.

All identifiers in anchors are guaranteed unique over all the processed files by MLMD.

There is no absolute best method, the choice for the right method is context dependent.

#### Named HTML anchors: `htmlold` mode

This mode uses plain old HTML style `<a name"id">` anchors to headings targets and `<a href>` links in the TOC. It is best used in vanilia HTML context for existing documentation
or system, to keep maximum compatibility with possibly old Web browsers.

#### Identified HTML anchors: `html` mode

Recent standards have replaced the `name` attribute in HTML `<A>` anchors by the `id` attribute, which has the benefit of automatic interfacing with Javascript.
This mode uses the new `id` attribute for anchors and `<a href>` links in the TOC and is well suited for HTML documentation in a modern, dynamic scripted environment.

#### Anchored Markdown: `md` mode

This hybrid mode uses HTML anchors with the `id` attribute and `[]()` Markdown links in the TOC. It is appropriate for software or Github documentation
 and works in a lot of different situations where HTML is allowed.

#### Pure Markdown: `mdpure` mode

This mode generate Markdown `{#}` anchors for headings and uses `[]()` Markdown links in the TOC. It is well suited in pure Markdown contexts or when files are
automatically checked against Markdown conformity. However Markdown anchors may not work in all Markdown processors.; so if that happens, the `md` mode can be a better choice.

#### About non-unique headings

Except for a warning from Markdown lint tools, identical headings are not an actual issue *if they are not targeted by any link*. MLMD allocates anchor identifiers
over all the processed files so even identical headings can be targeted unambigously in the TOC. However the user cannot know the MLMD identifiers before processing
the files, so links in the text body cannot use the MLMD anchors.

To solve this, the best way is to  explicitely add anchors to the identical headings so they can be referenced in links. Either Markdown orHTML syntax can be used.
MLMD will ignore these anchors and links and simply reproduce them in the generated files, provided they don't use the `a<integer>` format used by MLMD. (E.g. `a12`.).
MLMD will add its own anchors and links which won't interfere with the text body anchors and links.

### Headings numbering: `-numbering` argument

The `-numbering` parameter sets a numbering scheme for headings levels over all the generated files and in the tables of contents.
For example, a third level heading could be numbered `A.2.5) Using objects`. The numbering can be set in two ways

* globally for all generated files, using the `-numbering` script argument
* file by file using the `.numbering` directive.

The script argument has priority and will make MLMD ignore any file `.numbering` directive. The following addresses the script argument,
the syntax is identical for the file directive and is addressed later.

#### Syntax

The parameter consists of any number of levels definitions separated by a comma:

```code
-numbering [<level>]:[<prefix>]:<symbol>[<separator>][,...]]
```

Following are details about each definition part.

* `<level>` is optional and is a digit between `1` and `9` representing the heading level (which is the number of '#' at the heading beginning). By default, this defines the next level, starting with 1 and incrementing at each definition.
* `:` is a mandatory separator between parts of the definition.
* `prefix` is an optional prefix for the level numbering, e.g. '`Chapter `'. The prefix only appears in the level numbering for the heading of this level, and will be omitted from inferior levels numbering.
* `<symbol>` is a mandatory symbol which can be an uppercase letter `A` to `Z`, a lowercase letter from `a` to `z` or a digit from `1` to `9`. It sets the starting symbol for the level numbering.
* `separator` is an optional symbol which will be concatenated to the numbering symbol before the next level numbering. Conventional symbols can be `.`, `-`or `)`. Omitting this separator for the last level is identical to using `)`.
* `,` is a separator before the next level definition.

A level always starts with the defined symbol, then all the following headings at the same level will increment this symbol. A Heading with a level above will reset the current level, and continue with the next number in the setting for the above level.

#### Example

This is how to number level 1 headings with the 'A', 'B' etc letters followed by a dash `-`, then add a number followed by a dot `.` for level 2 headings, then add a number for level 3 headings:

```code
-numbering 1:Chapter :A-,2::1.,3::1
```

* Levels 4 and above headings will not be numbered and will not appear in table of Contents if the .toc directive doesn't ask for them. If they apear in TOC, they will use a dash '`-`' as prefix.
* The first level 1 heading will be prefixed and appear as `Chapter A)`
* Level 2 headings will be numbered `A-1)`, `A-2)` etc. The level A prefix doesn't apply to level 2 numbering.
* Level 3 headings will be numbered `A-1.1`, then `A-1.2`, `A-1.3` etc.

Any level can use a prefix, but as noted above the prefix only apply to their level headings and won't be used in inferior headings numbering.

## Writing templates files

The file templates must be named with a `.base.md` or `.mlmd` extension. They are UTF-8 text files with Linux/macOS or Windows end of lines. MLMD is UTF-8 compliant so macOS and Windows encoding could have side effect, as any character between codes 128 and 255 would be invalid UTF-8. The template files must use UTF-8 for any characters other than ASCII.

The user has total control over which languages he/she wants to put in the templates. Eachh language must be declared with one user choosen code. Using ISO standard codes like `en-US` or `fr-FR` allow to easily link standard Web APIs for nation flags or other international content, but more simple codes like `en` or `fr` are faster and easier to write.

See [`.language` directive](#declaring-languages-languages-directive) for the syntax of languages declaration.

### Headings

- MLMD requires `#` prefixed headings and doesn't recognize the alternate syntax for level 1 and 2 headings, which is available by adding `==` or `--` on the line
  following the heading. The `==`and `--` lines can be used but will not be sufficient for a heading to be recognized by MLMD.

  ```code
  # This heading will be found by MLMD

  This one won't be found because it doesn't have a # prefix
  ==========================================================

  ## This one will be found
  =========================
  ```

- At least one space must follow the `#`s prefix.
- Closing `#` are allowed but have no effect.

### End-of-Lines and End-of-Paragraphs

MLMD templates are interpreted on a paragraph basis, meaning that default text and languages specific text parts
will reproduce end of lines as-is and take effect only when either *two end of lines* or *the end of file* is met.

Generally, text outside any directive - including end-of-lines - would go into all the generated files, however MLMD makes an exception
for end-of-line characters when they only separate two directives with no other text between them. In that case, the end-of-line is not
sent to any generated files. This features helps a better text organisation while conforming to Markdown.

Normal Markdown conventions generally assume that text lines should not be larger than about 80 characters
but MLMD templates do not enforce this limit. All text for all languages of a given paragraph can
be typed on a single line or not, and use any line length.

Here is an example:

```code
.((default text.))
.fr((french text.))
.en((english text.))

Some other text...
```

MLMD interprets the three lines block this way:

1. The block starts line 1 by setting default text which will go in all generated file except thos for which a language specific section is found.
2. The end-of-line at line 1 is ignored because it is immediately followed by another directive.
3. Line 2 will put text only in the FR file, which will ignore the default text.
4. The end-of-line at line 2 is ignored because it is immediately followed by another directive.
5. Line 3 will put text only in the EN file, which will ignore the default text.
6. The double end-of-line after line 3 ends the paragraph and generates text in relevant files.

Because end-of-lines are ignored when they only separate directives, the following line is identical to the previous example:

```code
.((default text.)).fr((french text.)).en((english text.))

Some other text...
```

The ignored end-of-line feature allow for easy line length Markdown conformance while clearly separating languages parts.

#### Notes

Although Markdown syntax limits lines to little more than 80 characters, Markdown viewers and Web Browsers generally do not
bother about this limit and will display the text correctly. Similarly, modern text editors will make the text fit into the
displayed width even if there is no end of line. Most often they feature a 'soft-wrapping' setting or viewing option in menus
to put artificial end-of-lines which aren't actually in the file. For example, this option is called *Toggle Word Wrap* in
Visual Code and is accessible ![in the *View* menu:](Images/word_wrap_vscode.png).

Although this is not mandatory, it is best to be consistent in the style of opening and closing directives relatively to their text.
A file should either use separate lines around the text for both the opening and the closing directives, either put them on the same line around
the text but avoid mixing both techniques.

* Separated lines:
  ```code
  .fr((
  Some french text.
  .))
  ```

* Same line:
  ```code
  .fr((Some french text..))
  ```

### Escaping text

Directives and variables can be neutralized in a text portion by surrounding it with the opening escape `.{` and the closing escape `.}`
directives. The directives won't be copied to generated files, and variables and other directives will be copied as-is without axpansion or interpretation.

* Example:
  ```code
  The .{.numbering.} directive sets the numbering scheme.
  ```

### Quoted text and code fences

MLMD roughly copies the parts of text which are surrounded by *back-ticks* (reversed quote), *double quotes* and *code fences*.
In these parts of text, MLMD doesn't interpret directives and variables:

* .{`` ``` ``.}: code fences surround code text in which directives and variables will not be interpreted.
* `"`: double quotes around text neutralize directives and variables, e.g. `".(("` will not close the current directive.
* .{`` ` ``.}: back-ticks around text also neutralize directives and variables, e.g. .{`.((`.} will not close the current directive.

> Quoted and fenced text must be entirely put *inside* enclosing directives (default or language directives) as they cannot embed directives.
> Simple quotes `'` have *no neutralizing effect*, so text surrounded by `'` *can embed directives*. MLMD has been designed this way because the simple quote character is used separately in a lot of languages for other uses than surrounding text.
> Escaping back-ticks: to use actual back-ticks `` ` `` without the special effect, they can be embedded in doubled back-ticks with spaces (see [Markdown syntax about escapes](https://daringfireball.net/projects/markdown/syntax#autoescape)) and this whole sequence sourrounded by MLMD escaping.

### Variables

MLMD recognizes a few *variables*. These variables can be put anywhere in headings or text in the templates and will take a language specific value in the generated files.

* The `{file}` variable will be replaced by the name of the generated file itself (e.g: `file.en.md`). This allows to link somewhere in the generated file whichever language is concerned.
* The `{language}` variable will be replaced by the language code in each generated file (e.g: `en`). This can be used to link to Web content or APIs.
* The `{main}` variable will be replaced by the generated main file path (from the `-main` script argument). This allows to link to anchors in the main file, like a global table of content for example.

Each variable takes a value at generation time, except for `{main}` which is only converted to a value if a `-main` argument has been passed to MLMD. If no `-main` file is defined, the text will stay as `{main}` in the generated files.

### Default text

MLMD accepts default text in any part of the template: headings, table of contents title, normal text etc. The default text is used by MLMD when no language directive has been used to specify the language specific text.

This feature will be described in [Default text: `.DEFAULT((` or `.((` directive](#default-text-default-or-directive).

### Directives

Actions for generating the language specific files are set by *directives* in the templates.

Directives are of two types:

1. Immediate Directives begin with a dot `.` and are followed by parameters: they modify some of the MLMD settings
2. Language Directives enclose text between an opening marker `((` and an ending marker `))`

Here's a summary of the immediate directives:

* `.languages` declares the language codes available in all processed template(s).
* `.numbering` sets the numbering scheme for the file headings and TOC.
* `.toc` generates a Table Of Contents.

Here's a summary of open/close directives:

* `.all((` starts a text section which will be put in all the language files.
* `.default((` or `.((` starts a section which will be put in the language files for which no language section is available on the same line.
* `.ignore((` starts a text section which will not be put in any generated file.
* `.<code>((` starts a text section which will be put only in the generated file for language `<code>` which has been declared in the `.languages` directive.
* `.))` ends a section started by one of the `.((` directives and returns to the previous directive effect.
* `.{` starts an escaped text section (directives and variables are not interpreted or expanded)
* `.}` ends an escaped text section

Directives are not case sensitive: `.fr((` is the same as `.FR((`.

Directives are not interpreted in escaped text, see [Quoted text and code fences](#quoted-text-and-code-fences).

### Immediate vs enclosed effect

The `.languages`, `.numbering` and `.toc` directives have an *immediate effect*. It imply that they generally should
be alone on a single isolated line, and preferably at the beginning of template files. (This is mandatory for `.languages`.)

The other directives start with an opening `.<directive>((` marker which *encloses text* until a matching `.))` is met, or until another `((` directive is opened.

> These enclosing directives can be embedded: each `.<directive>((` opening will suspend the previous directive effect, and the matching `.))` closing will resume it.

### Default directives values and effects

Details will follow but it must be mentionned that the script has some defaults and that directives themselves also have defaults settings.

* Anything preceeding the `.languages` directive is *ignored* and won't be written in generated files. See [Declaring languages](#declaring-languages-languages).
* Empty lines before the level 1 heading are ignored.
* After the `.languages` directive, the generator acts as if a `.all((` directive had been met, so any text will go into all the languages files even before the level 1 heading. Notice that text preceding level 1 heading is not Markdown compliant.
* The `.default((` or `.((` directive will only have effect on languages which do not have a defined content yet, any previous `.all` text will make `.default` useless. See [Default directive](#default-text-default-or-).
* The `.toc` directive has default values which generate an table of contents for local headings in the current file only. See [TOC](#generating-table-of-content-toc).
* The table of contents generated in any file always has an implicit anchor named `toc` which can be used to link to it from any other file.

## Declaring languages: `.languages` directive

The `.languages` directive declares the possible languages which can be found in the templates and optionally tells which one is the *main* language.

The *main* language has files generated without the language code suffix, e.g. *README.md* while other languages will have the language code suffix, e.g. *README.fr.md*.

### Syntax

```code
.languages <code>[=<iso>][,...] [main=<code>]
```

Each  `<code>` declares a language which can then be used with `.<code>((` directives to start text sections for the `<code>` language.

The optional `main=<code>` parameter tells which language is the main language: files generated for this main language will have an `.md` extension instead of a `.<code>.md` extension. As an example, `README.base.md` will generate a `README.md` for the main language, and a `README.<code>.md` for other language codes. This is particularly useful with Git deposits which require a `README.md` file at the deposit root.

### Notices

* No file is generated before the `.languages` directive is met: any preceeding text will be ignored.
* The `.languages` directive is global so it can be put in the first processed file. If there is any doubt about which file will be processed first, the directive can be put in all the templates with no undesirable effect.
* After the `.languages` directive, the generator will send output to all languages until a directive changes this. See the [`.all((` directive documentation](#generating-for-all-languages-all).

### Example

```code
.languages en,fr main=en
```

Generated files will be named with a `.md` extension for the `en` language and with `.fr.md` for the `fr` language.

## Defining a numbering scheme: `.numbering` directive

The `.numbering` directive defines the numbering scheme for current file headings and TOC lines. The syntax is identical to the `-numbering` command line argument.

> WARNING: If a `-numbering` command line argument has been given, the `.numbering` directive will have no effect.

### Syntax

```code
.numbering [<level>]:[<prefix>]:<symbol>[<separator>][,...]]
```

Following are details about each definition part.

* `<level>` is optional and is a digit between `1` and `9` representing the heading level (which is the number of '#' at the heading beginning). By default, this defines the next level, starting with 1 and incrementing at each definition.
* `:` is a mandatory separator between parts of the definition.
* `prefix` is an optional prefix for the level numbering, e.g. '`Chapter `'. The prefix only appears in the level numbering for the heading of this level, and will be omitted from inferior levels numbering.
* `<symbol>` is a mandatory symbol which can be an uppercase letter `A` to `Z`, a lowercase letter from `a` to `z` or a digit from `1` to `9`. It sets the starting symbol for the level numbering.
* `separator` is an optional symbol which will be concatenated to the numbering symbol before the next level numbering. Conventional symbols can be `.`, `-`or `)`. Omitting this separator for the last level is identical to using `)`.
* `,` is a separator before the next level definition.

## Generating Table Of Content: `.toc` directive

The `.toc` directive generates a Table Of Contents using choosen header levels.

The header levels are defined by the `#` prefixes in Markdown syntax: `#` is header level 1, `##` is level 2 etc.

By default, level 1 is ignored: it is considered as the file title, and levels 2 to 4 are put in TOC. But level 1 can be used to build a global TOC for a set of files.

The Table of Contents has one link for each accepted heading.

> The table will be put at the place of the `.toc` directive.
> The table has an automatic anchor named `toc` which can be used in links from other files.
> If a numbering scheme has been set with the `-numbering` script argument or `.numbering` directive, it will be used for the toc headings.

### Syntax

The `.toc` directive must be written alone on its line with its parameters. Most of the time, the TOC lies after the file title and some introduction. A default TOC with no parameters will build a table of contents for the current file with headings `##` to `####`.

```code
.TOC [level=[m][-][n]] [title=m,"<title text>"] [out=md|html]
```

#### `level` parameter

This parameter sets the headings which will appear in the TOC.

Syntax for this parameter is `level=[m][-][n]`:

* If neither `m` nor `n` are given, the TOC will contain heading levels 2 to 4 (matching headings `##` to `####`).
* If `m` only is given, TOC titles will be level `m` headings only.
* If `m-` is given without `n`, TOC titles will be level `m` to level 9 headings.
* If `m-n` is given, TOC titles will be level `m` to level `n` headings.
* If `-n` is given, TOC titles will be level 1 to level `n` headings.

#### `title` parameter

Syntax for this parameter is `title=m,"<title text>"`:

* `t` is the heading level for the TOC title itself. Level 2 is recommended. (The TOC title will be a `##` heading.)
* The title text can use language, all, ignore and default directives.
* If no title text is given, `Table Of Contents` will be used.
* If no title parameter is given, level 2 will be used.
* The double quotes `"` around the title text are mandatory. If they are missing, an error is displayed and the rest of text following `title=` on the line is used as title text.

### Examples

```code
.TOC level=1-3 title=2,".fr((Table des matières.)).en((Table Of Contents))"
```

This directive generates a TOC using the headings `#` to `###` found in each file.

The table title will be `## Table des Matières` in the `.fr.md` file, and `## Table Of Contents` for other languages.

## Generating for all languages: `.all((` directive

The `.all((` directive starts a section of text which will be put in each of the languages files declared in the `.languages` directive.

This directive is ended or suspended by:

* The `.))` directive which returns to previous state.
* The `.<code>((` directives which start a language specific portion of text.
* The `.ignore((` directive which starts ignored text.
* The `.default((` or `.((` directive which starts the default value for a portion of text.

By default, any text outside directives and appearing after the `.languages` directive is generated in all the languages files as if it were in an `.all((` section.

### Syntax

```code
.all((
```

### Examples

Directives can always be alone on a line, surrounding the text they act on:

```code
.all((
text for all languages
.))
```

They can also be put inline within text:

```code
.en((text for 'en' language .all((text for all languages.)) rest of text for 'en' language.))
```

And they can be embedded within headings:

```code
# .en((Heading text for English .all(added text for all languages.)) heading text for English again .)) text for all languages
```

## Default text: `.default((` or `.((` directive

The `.default((`  or `.((` directive starts a default text section which will be put in the generated language files for which
no specific language section is yet available in the same paragraph.

This directive only has effect on a paragraph, and only for languages for which no content has been stored on this paragrah yet.
Only the first `.default((` or `.((` directive will have an effect, others appearing later in the paragraph will be ignored.

Putting text in `.default((` is **not** the same as `.all((`. Text for all languages will go in every generated files, while
default text will only go in files for which there is no language section on the same line.

The goal of the `.default((` directive is to prepare the original text and headings in a common language like english, then add
language specific sections on the fly while still having the default text for languages which are not translated yet.

### Syntax

```code
.default((
```

or:

```code
.((
```

### Examples

An obvious use of default text is in headings:

```code
# .default((Main Title.)).fr((Titre principal.))
```

This will put `# Main Title` in all the generated files except the `.fr.md` file where the generator will put `# Titre Principal`.

For text blocks, the default directive is a little sensitive because it will only apply to languages which have
absolutely no specific section yet, and any preceding text outside directives would go in all languages and neutralize default text.
The common use is to avoid any text outside a directive or at least, to keep translated sections near the matching default section,
like in the following example:

```code
.((This is the default original text..)).fr(ceci est la traduction en français..))
```

This will put `This is the default original text.` in all files except the `.fr.md` file where it will put `Ceci est la traduction en français.`.

Notice that text *outside directives* will go in all generated files, whether there is a default section or not.

If you mix default text with text outside directives or use more than one default directivein a paragrah, you will have side effects and probably unexpected results. Only the first default section will be used by the generator, and any text in an `.all((` section will cancel the default text.

To get predictable and expected results, make sure you put your default section first and you don't put text outside language sections. (See [Generating for languages](#generating-for-languages-code).)

## Ignoring text: `.ignore` directive

The `.ignore` directive starts an ignored section of text. Ignored text won't be put in any generated file. It is useful for TODO, comments, work-in-progress documentation parts which are not ready or appropriate for final generated files.

This directive is ended or suspended by:

* The `.))` directive which returns to previous state.
* The `.all((` directive which starts a section for all languages.
* The `.<code>((` directives which start a language specific portion of text.
* The `.default((` or `.((` directive which starts the default value for a portion of text.

### Syntax

```code
.ignore((
```

### Example

```code
.ignore((
text to ignore
.))
```

It can also be put inline within text or headings:

```code
text to generate .ignore((text to ignore.)) other text to generate
# Title for all languages .ignore((ignore this.))
```

## Generating for languages: `.<code>((`  directives

The `.<code>((` directive starts a section of text which will be only put in the generated file for the `<code>` language and no other file. The language `<code>` must have been declared in the `.languages` directive or the section is ignored.

This directive is ended or suspended by:

* The `.))` directive which returns to previous state.
* Another `.<code>((` directive which start another language specific section.
* The `.all((` directive which starts a section for all languages.
* The `.ignore` directive which starts ignored text.

Language sections must be closed by a matching `.))`. Although sections can be chained, it is recommended to close a section before beginning an other one, else you'll have to close all of them at the end of sections. See examples below for language chaining.

### Syntax

```code
.<code>((
```

### Examples

The directive can enclose text or headings:

```code
.en((
Text for English language only.

### Heading for English generated file
.))
```

It can also be put inline within text or headings:

```code
.fr((Texte pour le fichier en Français.)).en((text for the English file.))

# .fr((Titre en Français.)).en((English Title.))
```

Notice that the apparently ending '.' in titles is in fact the dot from the `.))` directive. This somewhat misleading visual effect can be avoided by using spaces:

```code
.fr((Texte en Français.)) .en((English text.))
```

The spaces between directives are not put in the generated text. To put a space after some text it must put inside the directive:

```code
.fr((Texte en Français suivi d'un espace .)) .en((English text followed by a space .))
```

As mentioned above, language sections can be chained without closing them, but each one will have to be closed in the end. The line below has the same effect as the previous example:

```code
.fr(( Texte en Français .en(( English text .)).))
```

A section not closed stays active until it is closed or until next directive is met. In the next example, the closing on the first line ends the `.en` section, but the `.fr` stays active and the following text will be generated in the `.fr.md` file, until another `.))` is found.

```code
This text has no directive and will go in all files.
.fr(( Texte en Français .en(( English text .))
This text will only go into the french file because the opening . fr (( directive has not been closed yet. .))
Now this text is in the `all` section and go in all files.
# .fr(( Titre en Français .en(( English Title .))
This text will only go into the french file because its opening directive has not been closed yet.
```

## Escaping text: `.{` and `.}` directives

Any text can be 'escaped' by surrounding it with `.{` and `.}`.

In the escaped text, directives and variables are ignored and text is copied as-is in the generated files.

In Markdown syntax, text can also be escaped by surrounding it with multiple back-ticks, like code fences .{`` ``` ``.} or double back-ticks .{`` `` ``.}. 
To actually write the escape sequence in the generated Markdowns, the MD escape sequence itself can be embedded in MLMD escaping:

`.{`.{`` back-tick is '`' ``.}`.}`


## Examples

The `Examples` directory has a few `mlmd` and `base.md` examples templates.

## Conclusion

Use MLMD to write multilingual documentations templates instead of maintaining different Markdown files for each language.

Here are some notes.

- Files
  - Template files must be UTF-8 encoded.
  - Use the `.mlmd` extension to distinguish MLMD templates from actual Markdown files.
  - Use the `-numbering` script argument to consistently number headings over all files and in TOCs.
  - Use the '-out' script argument to have anchors and links adapted to your MD or HTML context.
  - Use `-i` script arguments to choose the files to process, or omit `-i` to process all the
    template files in current directory and subdirectories.

- Headings, paragraphs
  - Headings must have a `#`s prefix.
  - Separate paragraphs with one empty line.
  - Use a default text for each paragraph and heading with the `.((` directive, then add languages translations
    after the default text using `.<code>((` directives.
  - Close each opened directive with `.))`).
  - Use one end-of-line between directives if you want to visually separate different sections without
    actually generating an end-of-line
  - Do not use `.((` default text *and* `.all((` text together in a paragraph.
  - Use the variables to put language specific links or images in text body.

- Table Of Contents (TOC)
  - Use level 1 in `.toc` directive to generate a global TOC with links to all the processed templates.
  - Use levels 2 to 9 in local `.toc` directive to link to headings in each file.
  - Give your `.toc` directive a title and a heading level of 2
  - Place your `.toc` directive after a level 1 heading and introductory text
  - Use links to `#toc` anchor to place a link to the TOC in your text.

I hope MLMD will help you to easily maintain multilingual documentations.

F. Piérot
August 2020